import sys
import numpy as np
import sounddevice as sd
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QFrame
)
from PyQt6.QtCore import QTimer, Qt
import pyqtgraph as pg
import queue
from typing import List

# -----------------------------------------------------------------------------
# 定数 (Constants)
# -----------------------------------------------------------------------------

# (M系列データと各種設定は変更ないため、ここでは省略します)
# --- M系列データ (Android版のコードからコピー) ---
M_SEQUENCE_RAW_DATA: List[float] = [
    -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0,
    -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0,
    -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0,
    1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0,
    1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0,
    -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0,
    -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0,
    1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0,
    1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0,
    -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0
]
MODIFIED_M_SEQUENCE_RAW_DATA = [0.969223 if x == 1.0 else -1.029800 for x in M_SEQUENCE_RAW_DATA]
M_SEQUENCE = np.array(MODIFIED_M_SEQUENCE_RAW_DATA, dtype=np.float32) * -1.0

# --- オーディオ設定 (Audio Settings) ---
SAMPLE_RATE = 96000
CHANNELS = 1
DEVICE = None
BLOCK_DURATION_MS = 50
BLOCKSIZE = int(SAMPLE_RATE * BLOCK_DURATION_MS / 1000)

# --- 分析設定 (Analysis Settings) ---
ANALYSIS_INTERVAL_MS = 2000
ANALYSIS_DURATION_S = 2
BUFFER_DURATION_S = ANALYSIS_DURATION_S + 2
CORRELATION_ADJUSTMENT_FACTOR = 0.9995

# --- UI / グラフ設定 (UI / Graph Settings) ---
GRAPH_VIEWPORT_WIDTH_MS = 10.98
Y_AXIS_RANGE = (-1.0, 1.0)
Y_ZOOM_LEVELS = [1.0, 2.0, 3.0]

# --- レベル評価 (Level Evaluation) ---
MIN_DB_LEVEL = -120.0
LEVEL_THRESHOLD_LOW = -40.0
LEVEL_THRESHOLD_IDEAL_LOW = -20.0
LEVEL_THRESHOLD_IDEAL_HIGH = -6.0
LEVEL_THRESHOLD_HIGH = -3.0

class MainWindow(QMainWindow):
    """メインウィンドウクラス"""
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Python 相互相関アナライザー (ポスト等化版)")
        self.setGeometry(100, 100, 1000, 700)

        # --- 状態変数 (State Variables) ---
        self.is_recording = False
        self.audio_stream = None
        self.audio_queue = queue.Queue()
        self.audio_buffer = np.array([], dtype=np.float32)
        self.current_y_zoom_index = 0
        
        # ★変更点: ポスト等化係数を読み込む
        self.equalizer_coeffs = None
        self._load_equalizer_coeffs()

        # --- UIのセットアップ ---
        self._init_ui()

        # --- タイマーのセットアップ ---
        self.analysis_timer = QTimer(self)
        self.analysis_timer.setInterval(ANALYSIS_INTERVAL_MS)
        self.analysis_timer.timeout.connect(self._perform_analysis)

    def _load_equalizer_coeffs(self):
        """postcorder.txtから等化係数を読み込む"""
        try:
            # txtファイルから2列のデータを読み込む
            data = np.loadtxt('postcorder.txt', dtype=np.float32)
            # 1列目を実部、2列目を虚部として複素数配列を生成
            self.equalizer_coeffs = data[:, 0] + 1j * data[:, 1]
            # status_labelはまだ存在しないのでprintで通知
            print(f"通知: postcorder.txtから{len(self.equalizer_coeffs)}個の等化係数を読み込みました。")
        except FileNotFoundError:
            print("警告: postcorder.txt が見つかりません。ポスト等化は無効になります。")
        except Exception as e:
            print(f"エラー: postcorder.txt の読み込みに失敗しました: {e}")

    def _init_ui(self):
        """UI要素を初期化して配置する"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        control_layout = QHBoxLayout()
        self.start_button = QPushButton("録音開始")
        self.start_button.clicked.connect(self.start_recording)
        self.stop_button = QPushButton("停止")
        self.stop_button.clicked.connect(self.stop_recording)
        self.stop_button.setEnabled(False)
        self.zoom_button = QPushButton("拡大")
        self.zoom_button.clicked.connect(self._cycle_y_zoom)
        self.reset_button = QPushButton("リセット")
        self.reset_button.clicked.connect(self._reset_y_zoom)
        control_layout.addWidget(self.start_button)
        control_layout.addWidget(self.stop_button)
        control_layout.addWidget(self.zoom_button)
        control_layout.addWidget(self.reset_button)
        
        status_layout = QHBoxLayout()
        self.status_label = QLabel("ステータス: 待機中")
        self.db_level_label = QLabel("入力レベル: --- dBFS")
        self.level_feedback_label = QLabel("")
        status_layout.addWidget(self.status_label, 1)
        status_layout.addWidget(self.db_level_label, 1)
        status_layout.addWidget(self.level_feedback_label, 1)
        
        self.plot_widget = pg.PlotWidget()
        self.plot_widget.setBackground('w')
        
        label_style = {'color': 'black', 'font-size': '16pt', 'font-family': 'Times New Roman'}
        self.plot_widget.setLabel('left', '正規化相関値', **label_style)
        self.plot_widget.setLabel('bottom', '時間差 (ms)', **label_style)

        axis_pen = pg.mkPen(color='k')
        tick_font = pg.QtGui.QFont('Times New Roman', 12)
        left_axis = self.plot_widget.getAxis('left')
        left_axis.setTextPen(axis_pen)
        left_axis.setStyle(tickFont=tick_font)
        bottom_axis = self.plot_widget.getAxis('bottom')
        bottom_axis.setTextPen(axis_pen)
        bottom_axis.setStyle(tickFont=tick_font)

        x_ticks = [(i, str(i)) for i in range(0, 51, 10)] # 0から50まで10刻みのリストを作成
        bottom_axis.setTicks([x_ticks])
        vb = self.plot_widget.getViewBox()
        vb.setXRange(0, GRAPH_VIEWPORT_WIDTH_MS, padding=0)
        vb.setYRange(Y_AXIS_RANGE[0], Y_AXIS_RANGE[1], padding=0)
        vb.setLimits(xMin=0, xMax=GRAPH_VIEWPORT_WIDTH_MS)
        self.plot_widget.showGrid(x=True, y=True)
        
        pen = pg.mkPen(color=(0, 120, 215), width=2)
        self.correlation_curve = self.plot_widget.plot(pen=pen)
        self.peak_scatter = self.plot_widget.plot(pen=None, symbol='o', symbolBrush='r', symbolSize=10)
        
        self.peak_text = pg.TextItem(anchor=(0, 1), color=(255, 0, 0))
        font = pg.QtGui.QFont('Times New Roman', 12)
        self.peak_text.setFont(font)
        self.plot_widget.addItem(self.peak_text)

        main_layout.addLayout(control_layout)
        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(line)
        main_layout.addLayout(status_layout)
        main_layout.addWidget(self.plot_widget)

        # 読み込み結果をステータスラベルに反映
        if self.equalizer_coeffs is None:
            self.status_label.setText("ステータス: 待機中 (フィルタファイル無)")
            self.status_label.setStyleSheet("color: red;")

    def _audio_callback(self, indata, frames, time, status):
        if status:
            print(status, file=sys.stderr)
        self.audio_queue.put(indata.copy())
        
    def start_recording(self):
        if self.is_recording: return
        with self.audio_queue.mutex: self.audio_queue.queue.clear()
        self.audio_buffer = np.array([], dtype=np.float32)
        try:
            self.audio_stream = sd.InputStream(samplerate=SAMPLE_RATE, blocksize=BLOCKSIZE, device=DEVICE, channels=CHANNELS, dtype='float32', callback=self._audio_callback)
            self.audio_stream.start()
            self.analysis_timer.start()
            self.is_recording = True
            self.status_label.setText("ステータス: 録音中...")
            self.status_label.setStyleSheet("color: black;")
            self.start_button.setEnabled(False)
            self.stop_button.setEnabled(True)
        except Exception as e:
            self.status_label.setText(f"エラー: {e}")
            self.status_label.setStyleSheet("color: red;")

    def stop_recording(self):
        if not self.is_recording: return
        self.analysis_timer.stop()
        if self.audio_stream:
            self.audio_stream.stop()
            self.audio_stream.close()
            self.audio_stream = None
        self.is_recording = False
        if self.equalizer_coeffs is None:
            self.status_label.setText("ステータス: 停止 (フィルタファイル無)")
            self.status_label.setStyleSheet("color: red;")
        else:
            self.status_label.setText("ステータス: 停止")
            self.status_label.setStyleSheet("color: black;")
        self.db_level_label.setText("入力レベル: --- dBFS")
        self.level_feedback_label.setText("")
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)

    def _perform_analysis(self):
        new_data = []
        while not self.audio_queue.empty(): new_data.append(self.audio_queue.get())
        if not new_data: return
        
        flattened_new_data = [block.flatten() for block in new_data]
        self.audio_buffer = np.concatenate([self.audio_buffer, *flattened_new_data])
        
        max_buffer_samples = int(SAMPLE_RATE * BUFFER_DURATION_S)
        if len(self.audio_buffer) > max_buffer_samples:
            self.audio_buffer = self.audio_buffer[-max_buffer_samples:]

        level_samples = self.audio_buffer[-int(SAMPLE_RATE * 0.1):]
        if level_samples.size > 0:
            rms = np.sqrt(np.mean(level_samples**2))
            dbfs = 20 * np.log10(rms) if rms > 1e-10 else MIN_DB_LEVEL
            self.db_level_label.setText(f"入力レベル: {dbfs:.1f} dBFS")
            feedback_text, color = "", "black"
            if dbfs < LEVEL_THRESHOLD_LOW: feedback_text, color = "音が小さい", "blue"
            elif LEVEL_THRESHOLD_IDEAL_LOW <= dbfs < LEVEL_THRESHOLD_IDEAL_HIGH: feedback_text, color = "理想的な音量", "green"
            elif dbfs >= LEVEL_THRESHOLD_HIGH: feedback_text, color = "音が大きい", "red"
            self.level_feedback_label.setText(feedback_text)
            self.level_feedback_label.setStyleSheet(f"color: {color};")
        
        samples_for_analysis = int(SAMPLE_RATE * ANALYSIS_DURATION_S)
        if len(self.audio_buffer) < samples_for_analysis: return
            
        long_signal = self.audio_buffer[-samples_for_analysis:]
        short_signal = M_SEQUENCE
        correlation = np.correlate(long_signal, short_signal, mode='valid')
        correlation *= CORRELATION_ADJUSTMENT_FACTOR

        short_energy = np.sum(short_signal**2)
        s = np.cumsum(long_signal**2)
        long_energy_window = s[len(short_signal)-1:] - np.concatenate(([0], s[:-len(short_signal)]))
        norm_factor = np.sqrt(short_energy * long_energy_window)
        norm_factor[norm_factor < 1e-9] = 1e-9
        normalized_correlation = correlation / norm_factor

        # ★変更点: ポスト等化フィルタを適用
        final_signal_for_graph = normalized_correlation
        if self.equalizer_coeffs is not None:
            N_filter = len(self.equalizer_coeffs)
            if len(normalized_correlation) >= N_filter:
                signal_segment = normalized_correlation[:N_filter]
                freq_domain_signal = np.fft.fft(signal_segment)
                equalized_freq_domain = freq_domain_signal * self.equalizer_coeffs
                equalized_time_domain = np.fft.ifft(equalized_freq_domain)
                final_signal_for_graph = equalized_time_domain.real
        
        self._update_graph(final_signal_for_graph)

    def _update_graph(self, correlation_data: np.ndarray):
        samples_for_display = int(SAMPLE_RATE * GRAPH_VIEWPORT_WIDTH_MS / 1000)
        display_data = correlation_data[:samples_for_display]
        if display_data.size == 0: return

        time_axis = np.arange(display_data.size) * (1000.0 / SAMPLE_RATE)
        self.correlation_curve.setData(time_axis, display_data)
        
        peak_index = np.argmax(display_data)
        peak_value = display_data[peak_index]
        peak_time = peak_index * (1000.0 / SAMPLE_RATE)
        self.peak_scatter.setData([peak_time], [peak_value])
        self.peak_text.setText(f"{peak_value:.3f}")
        self.peak_text.setPos(peak_time, peak_value)

    def _cycle_y_zoom(self):
        self.current_y_zoom_index = (self.current_y_zoom_index + 1) % len(Y_ZOOM_LEVELS)
        self._apply_y_zoom()

    def _reset_y_zoom(self):
        self.current_y_zoom_index = 0
        self._apply_y_zoom()

    def _apply_y_zoom(self):
        scale = Y_ZOOM_LEVELS[self.current_y_zoom_index]
        y_range_span = (Y_AXIS_RANGE[1] - Y_AXIS_RANGE[0]) / scale
        center = 0.0
        self.plot_widget.getViewBox().setYRange(center - y_range_span / 2, center + y_range_span / 2, padding=0)
        
    def closeEvent(self, event):
        self.stop_recording()
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())
