package com.example.graph

// ★★★ 必要な Import 文 ★★★
import android.Manifest
import android.content.pm.PackageManager
import android.graphics.Paint
// import android.graphics.Typeface // Not used directly
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.os.Bundle
import android.util.Log
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.RequiresPermission
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
// import androidx.compose.ui.graphics.drawscope.DrawScope // Not used directly
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.nativeCanvas // nativeCanvas へのアクセスに必要
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.ContextCompat
import androidx.compose.ui.platform.LocalDensity
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import androidx.compose.ui.text.style.TextOverflow
import kotlinx.coroutines.Job // Job をインポート
// import kotlinx.coroutines.cancel // Not used directly
import kotlinx.coroutines.delay // delay をインポート
import kotlinx.coroutines.isActive // isActive をインポート
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.concurrent.thread // 'thread' のための import
import kotlin.math.abs
import kotlin.math.ceil
import kotlin.math.round // ★★★ round をインポート ★★★
// import kotlin.math.floor // Not used directly
import kotlin.math.log10
import kotlin.math.min
import kotlin.math.pow
import kotlin.math.sqrt


// ★★★ M系列データを定数として定義 ★★★
private val M_SEQUENCE_RAW_DATA: List<Float> = listOf(
    1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f,
    1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f,
    1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f,
    -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f,
    1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f,
    -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f,
    -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f,
    -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f,
    1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
)
// FloatArray に変換しておく (効率のため)
private val M_SEQUENCE_FLOAT_ARRAY = M_SEQUENCE_RAW_DATA.toFloatArray()

// dB計算用の定数
private const val MIN_DB_LEVEL = -120.0f // dB表示の下限値
// ★★★ レベル評価の閾値 (dBFS) ★★★
private const val LEVEL_THRESHOLD_LOW = -40.0f // これ未満だと「小さい」
private const val LEVEL_THRESHOLD_IDEAL_LOW = -20.0f // これ以上が「理想的」の下限
private const val LEVEL_THRESHOLD_IDEAL_HIGH = -6.0f // これ未満が「理想的」の上限
private const val LEVEL_THRESHOLD_HIGH = -3.0f // これ以上だと「大きい」

// ★★★ グラフズーム関連の定数 ★★★
private const val INITIAL_GRAPH_VIEWPORT_WIDTH_MS = 50f // グラフの初期表示幅 (ms)
private const val MIN_Y_ZOOM_SCALE = 1.0f
private const val DEFAULT_Y_ZOOM_SCALE = 1.0f
private val Y_ZOOM_LEVELS = listOf(1.0f, 2.0f, 3.0f) // Y軸ズームレベルのサイクル

// ★★★ グラフY軸ズーム関連の定数 ★★★
private const val INITIAL_Y_AXIS_DATA_MIN = -1.0f
private const val INITIAL_Y_AXIS_DATA_MAX = 1.0f
private const val INITIAL_Y_AXIS_SPAN = INITIAL_Y_AXIS_DATA_MAX - INITIAL_Y_AXIS_DATA_MIN
private const val Y_AXIS_DEFAULT_CENTER = 0.0f


class MainActivity : ComponentActivity() {

    private val TAG = "AudioRecordSample"

    // --- オーディオ設定 ---
    private val sampleRate = 44100
    private val channelConfig = AudioFormat.CHANNEL_IN_MONO
    private val audioFormat = AudioFormat.ENCODING_PCM_16BIT
    private var minBufferSize = 0
    private var bufferSizeInBytes = 0

    // --- AudioRecord関連 ---
    private var audioRecord: AudioRecord? = null
    private var recordingThread: Thread? = null

    // --- データバッファと結果 ---
    private val recordedAudioBuffer = mutableListOf<Short>()
    private var correlationResult by mutableStateOf<List<Float>>(emptyList())

    // ★★★ 定期計算用コルーチン Job ★★★
    private var calculationCoroutineJob: Job? = null
    private val calculationIntervalMs = 2000L
    private val calculationDataDurationSec = 2

    // --- Compose UI の状態管理 ---
    private var hasPermission by mutableStateOf(false)
    private var isRecording by mutableStateOf(false)
    private var statusText by mutableStateOf("待機中")
    private var isInitialized by mutableStateOf(false)
    private var currentDbLevel by mutableStateOf(MIN_DB_LEVEL)
    private var levelFeedbackText by mutableStateOf("")

    // ★★★ グラフのズーム状態 ★★★
    // X軸は現状ボタン操作なしのため、常に初期状態
    private var graphScaleX by mutableStateOf(1.0f)
    private var graphOffsetX by mutableStateOf(0.0f)

    private var currentYZoomIndex by mutableStateOf(0) // Y_ZOOM_LEVELS のインデックス
    private val graphScaleY by derivedStateOf { Y_ZOOM_LEVELS[currentYZoomIndex] } // Y軸スケール ★★★ var から val に変更 ★★★
    private var graphOffsetY by mutableStateOf(Y_AXIS_DEFAULT_CENTER) // Y軸表示の中心値


    // --- パーミッションリクエストランチャー ---
    private val requestPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted: Boolean ->
            if (granted) {
                Log.d(TAG, "RECORD_AUDIO permission granted.")
                hasPermission = true
                try { initAudioRecord() }
                catch (e: SecurityException) { Log.e(TAG, "SecurityException calling initAudioRecord after permission granted!", e); statusText = "権限処理エラー（コールバック）"; hasPermission = false; isInitialized = false; Toast.makeText(this, "権限処理中に予期せぬエラーが発生しました", Toast.LENGTH_LONG).show()}
            } else { Log.w(TAG, "RECORD_AUDIO permission denied."); hasPermission = false; statusText = "マイク権限が拒否されました"; Toast.makeText(this, "マイク権限が必要です", Toast.LENGTH_SHORT).show() }
        }

    // --- Activity Lifecycle ---
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val scope = rememberCoroutineScope()
            MaterialTheme {
                CorrelationScreen(
                    hasPermission = hasPermission,
                    isRecording = isRecording,
                    statusText = statusText,
                    isInitialized = isInitialized,
                    correlationData = correlationResult,
                    currentDbLevel = currentDbLevel,
                    levelFeedbackText = levelFeedbackText,
                    sampleRate = sampleRate,
                    graphScaleX = graphScaleX,
                    graphOffsetX = graphOffsetX,
                    graphScaleY = graphScaleY,
                    graphOffsetY = graphOffsetY,
                    onYZoomCycleClick = { cycleGraphYZoom() },
                    onYResetZoomClick = { resetGraphYZoom() },
                    onStartClick = { startRecordingAndPeriodicCalculation(scope) },
                    onStopClick = { stopRecordingAndCalculation() },
                    onRequestPermission = { checkAndRequestPermission() }
                )
            }
        }
        checkAndRequestPermission()
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "onDestroy called.")
        stopRecordingAndCalculation()
        audioRecord?.release()
        audioRecord = null
        isInitialized = false
        Log.d(TAG, "AudioRecord released.")
    }


    // ★★★ グラフY軸ズーム処理関数 (Y軸のみ変更、サイクル式) ★★★
    private fun cycleGraphYZoom() {
        currentYZoomIndex = (currentYZoomIndex + 1) % Y_ZOOM_LEVELS.size
        // graphScaleY は derivedStateOf で自動的に更新される
        // オフセット(中心)は0.0で固定なので、再計算は不要 (常に中心が0.0で拡大・縮小)
        graphOffsetY = Y_AXIS_DEFAULT_CENTER // 念のため中心を再設定
    }

    private fun resetGraphYZoom() {
        currentYZoomIndex = Y_ZOOM_LEVELS.indexOf(DEFAULT_Y_ZOOM_SCALE) // 1.0f のインデックス
        // graphScaleY は derivedStateOf で自動的に更新される
        graphOffsetY = Y_AXIS_DEFAULT_CENTER
    }


    // --- UI定義 (Compose) ---
    @Composable
    fun CorrelationScreen(
        hasPermission: Boolean,
        isRecording: Boolean,
        statusText: String,
        isInitialized: Boolean,
        correlationData: List<Float>,
        currentDbLevel: Float,
        levelFeedbackText: String,
        sampleRate: Int,
        graphScaleX: Float,
        graphOffsetX: Float,
        graphScaleY: Float,
        graphOffsetY: Float,
        onYZoomCycleClick: () -> Unit,
        onYResetZoomClick: () -> Unit,
        onStartClick: () -> Unit,
        onStopClick: () -> Unit,
        onRequestPermission: () -> Unit
    ) {
        Column(
            modifier = Modifier.fillMaxSize().padding(8.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                val buttonModifier = Modifier.weight(1f).height(46.dp)
                val buttonFontSize = 24.sp

                Button(
                    onClick = onStartClick,
                    enabled = hasPermission && isInitialized && !isRecording,
                    modifier = buttonModifier
                ) { Text("録音開始", fontSize = buttonFontSize) }

                Button(
                    onClick = onStopClick,
                    enabled = isRecording,
                    modifier = buttonModifier
                ) { Text("停止", fontSize = buttonFontSize) }

                Button(
                    onClick = onYZoomCycleClick, // サイクルズーム関数を呼び出し
                    modifier = buttonModifier
                ) { Text("拡大", fontSize = buttonFontSize) } // ボタン名を「拡大」に変更

                Button(
                    onClick = onYResetZoomClick,
                    modifier = buttonModifier
                ) { Text("リセット", fontSize = buttonFontSize) } // ボタン名を「リセット」に変更
            }

            Spacer(modifier = Modifier.height(8.dp))

            Row(
                modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(text = statusText, fontSize = 24.sp, textAlign = TextAlign.Center, modifier = Modifier.weight(1f), maxLines = 2, overflow = TextOverflow.Ellipsis )
                Text(text = "入力レベル: ${String.format("%.1f", currentDbLevel)} dBFS", fontSize = 24.sp, color = MaterialTheme.colorScheme.onSurfaceVariant, textAlign = TextAlign.Center, modifier = Modifier.weight(1f), maxLines = 1, overflow = TextOverflow.Ellipsis)
                Text(
                    text = if (levelFeedbackText.isNotBlank()) levelFeedbackText else " ",
                    fontSize = 20.sp,
                    color = when {
                        levelFeedbackText.contains("小さい") -> Color.Blue
                        levelFeedbackText.contains("理想的") -> MaterialTheme.colorScheme.primary
                        levelFeedbackText.contains("大きい") -> Color.Red
                        else -> Color.Transparent
                    },
                    textAlign = TextAlign.End,
                    modifier = Modifier.weight(1f).heightIn(min = (20.sp.value * LocalDensity.current.fontScale * 1.2f).dp),
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
            }

            Spacer(modifier = Modifier.height(8.dp))

            CorrelationGraph(
                result = correlationData,
                sampleRate = sampleRate,
                scaleX = graphScaleX,
                offsetX = graphOffsetX,
                scaleY = graphScaleY,
                offsetY = graphOffsetY,
                modifier = Modifier.fillMaxWidth().height(520.dp)
            )

            if (!hasPermission) { Spacer(modifier = Modifier.height(8.dp)); Text(text = "マイクを使用するには権限が必要です。\nアプリ設定から許可してください。", color = Color.Red, textAlign = TextAlign.Center) }
            Spacer(modifier = Modifier.weight(1f))
        }
    }

    @Composable
    fun CorrelationGraph(
        result: List<Float>,
        sampleRate: Int,
        scaleX: Float,
        offsetX: Float,
        scaleY: Float,
        offsetY: Float, // offsetYは現状0.0で固定だが、将来的なパン操作のために残す
        modifier: Modifier = Modifier
    ) {
        val primaryColor = MaterialTheme.colorScheme.primary
        val orangeColor = Color(0xFFFFA500)
        var peakInfo by remember(result) { mutableStateOf<Pair<Int, Float>?>(null) }

        val resources = LocalContext.current.resources
        val density = resources.displayMetrics.density
        val labelTextSizePx = remember { 28.sp.toPx(density, resources.configuration.fontScale) }
        val tickLabelTextSizePx = remember { 28.sp.toPx(density, resources.configuration.fontScale) }

        val axisLabelPaint = remember { Paint().apply { color = android.graphics.Color.BLACK; textAlign = Paint.Align.CENTER; textSize = labelTextSizePx } }
        val tickLabelPaint = remember { Paint().apply { color = android.graphics.Color.DKGRAY; textAlign = Paint.Align.CENTER; textSize = tickLabelTextSizePx } }
        val yAxisValueLabelPaint = remember { Paint().apply { color = android.graphics.Color.DKGRAY; textAlign = Paint.Align.RIGHT; textSize = tickLabelTextSizePx } }
        val yAxisLabelPaint = remember { Paint().apply { color = android.graphics.Color.BLACK; textAlign = Paint.Align.CENTER; textSize = labelTextSizePx } }
        val peakValuePaint = remember { Paint().apply { color = orangeColor.toArgb(); textAlign = Paint.Align.LEFT; textSize = tickLabelTextSizePx } }

        LaunchedEffect(result) {
            if (result.isNotEmpty()) {
                var maxVal = -Float.MAX_VALUE; var maxIndex = -1
                for (i in result.indices) { if (result[i] > maxVal) { maxVal = result[i]; maxIndex = i } }
                if (maxIndex != -1) { peakInfo = Pair(maxIndex, maxVal) } else { peakInfo = null }
            } else { peakInfo = null }
        }

        Canvas(modifier = modifier) {
            val canvasWidth = size.width
            val canvasHeight = size.height
            val bottomPadding = labelTextSizePx * 2f
            val leftPadding = labelTextSizePx * 4.2f
            val topPadding = labelTextSizePx * 1f
            val rightPadding = labelTextSizePx * 2f

            val graphContentLeft = leftPadding
            val graphContentTop = topPadding
            val graphContentRight = canvasWidth - rightPadding
            val graphContentBottom = canvasHeight - bottomPadding
            val graphContentWidth = graphContentRight - graphContentLeft
            val graphContentHeight = graphContentBottom - graphContentTop

            if (graphContentWidth <= 0f || graphContentHeight <= 0f) return@Canvas

            // X軸ズーム対応のための計算 (現状は scaleX=1.0f, offsetX=0.0f で固定)
            val currentViewportWidthMs = INITIAL_GRAPH_VIEWPORT_WIDTH_MS / scaleX
            val visibleStartMs = offsetX
            val visibleEndMs = offsetX + currentViewportWidthMs

            // Y軸ズーム対応のための計算
            val currentViewportYSpan = INITIAL_Y_AXIS_SPAN / scaleY
            val visibleYMin = Y_AXIS_DEFAULT_CENTER - currentViewportYSpan / 2.0f // offsetYは0.0固定
            val visibleYMax = Y_AXIS_DEFAULT_CENTER + currentViewportYSpan / 2.0f // offsetYは0.0固定

            // --- 軸ラベル描画 ---
            val xLabelText = "時間差 (ms)"
            drawContext.canvas.nativeCanvas.drawText(xLabelText, graphContentLeft + graphContentWidth / 2f, canvasHeight - axisLabelPaint.descent() - (bottomPadding - labelTextSizePx * 3.8f)/2f , axisLabelPaint)
            val yLabelText = "正規化相関値"
            drawContext.canvas.nativeCanvas.save()
            drawContext.canvas.nativeCanvas.rotate(-90f)
            drawContext.canvas.nativeCanvas.drawText(yLabelText, -(graphContentTop + graphContentHeight / 2f), leftPadding * 0.3f, yAxisLabelPaint)
            drawContext.canvas.nativeCanvas.restore()

            // --- Y軸の線と目盛り描画 (Y軸ズーム対応) ---
            drawLine(color = Color.Black, start = Offset(graphContentLeft, graphContentTop), end = Offset(graphContentLeft, graphContentBottom), strokeWidth = 3.0f)
            if (currentViewportYSpan > 0) {
                val yTickInterval = when {
                    scaleY >= 2.9f -> 0.1f // 3倍ズーム
                    scaleY >= 1.9f -> 0.1f // 2倍ズーム
                    else -> 0.25f        // 1倍ズーム (デフォルト)
                }

                // 目盛りを -1.0 から 1.0 の範囲で、決定した間隔で生成
                val tickValues = mutableListOf<Float>()
                var currentTick = -INITIAL_Y_AXIS_DATA_MAX // -1.0f から開始
                while (currentTick <= INITIAL_Y_AXIS_DATA_MAX + 1e-6f) { // +1.0f まで (誤差許容)
                    if (currentTick >= visibleYMin - 1e-6f && currentTick <= visibleYMax + 1e-6f) {
                        // 浮動小数点誤差を考慮して、ほぼ0.25や0.1の倍数になっているかチェック
                        val remainderCheck = if (yTickInterval == 0.25f) abs(currentTick % 0.25f) else abs(currentTick % 0.1f)
                        val isCloseToMultiple = remainderCheck < 1e-5f || abs(remainderCheck - yTickInterval) < 1e-5f
                        if (isCloseToMultiple || currentTick == 0.0f || abs(currentTick) == 1.0f) { // 0, +/-1 は必ず含める
                            tickValues.add((round(currentTick * 100f)) / 100f) // 丸めて追加
                        }
                    }
                    currentTick += 0.01f // 細かいステップでチェックし、適切な間隔のものを拾う
                }
                // 1倍ズームの時は主要な目盛りを強制的に追加
                if (scaleY <= 1.01f) {
                    listOf(-1.0f, -0.75f, -0.5f, -0.25f, 0.0f, 0.25f, 0.5f, 0.75f, 1.0f).forEach { fixedTick ->
                        if (fixedTick >= visibleYMin - 1e-6f && fixedTick <= visibleYMax + 1e-6f && !tickValues.any { abs(it - fixedTick) < 1e-5f }) {
                            tickValues.add(fixedTick)
                        }
                    }
                }


                tickValues.distinct().sorted().forEach { currentYTick ->
                    val tickScreenY = graphContentTop + ((visibleYMax - currentYTick) / currentViewportYSpan) * graphContentHeight
                    if (tickScreenY >= graphContentTop && tickScreenY <= graphContentBottom + 1f) {
                        val tickLabel = if (abs(currentYTick - round(currentYTick)) < 1e-5f && (abs(currentYTick) == 1.0f || currentYTick == 0.0f)) {
                            String.format("%.1f", currentYTick)
                        } else if (abs(currentYTick * 2f - round(currentYTick * 2f)) < 1e-5f && (abs(currentYTick) == 0.5f)) {
                            String.format("%.1f", currentYTick)
                        } else if (abs(currentYTick * 4f - round(currentYTick * 4f)) < 1e-5f && (abs(currentYTick) == 0.25f || abs(currentYTick) == 0.75f)) {
                            String.format("%.2f", currentYTick)
                        }
                        else {
                            String.format("%.2f", currentYTick) // 0.1, 0.2, 0.3, 0.4 など
                        }
                        drawLine(color = Color.Black, start = Offset(graphContentLeft - 5.dp.toPx(), tickScreenY), end = Offset(graphContentLeft, tickScreenY), strokeWidth = 3.0f)
                        drawContext.canvas.nativeCanvas.drawText(
                            tickLabel,
                            graphContentLeft - 10.dp.toPx(),
                            tickScreenY + yAxisValueLabelPaint.textSize / 3f,
                            yAxisValueLabelPaint
                        )
                    }
                }
            }


            // --- X軸の線 (相関値0のライン) (Y軸ズーム対応) ---
            if (0.0f >= visibleYMin && 0.0f <= visibleYMax && currentViewportYSpan > 0) {
                val zeroLineYScreen = graphContentTop + ((visibleYMax - 0.0f) / currentViewportYSpan) * graphContentHeight
                if (zeroLineYScreen >= graphContentTop && zeroLineYScreen <= graphContentBottom) {
                    drawLine(
                        color = Color.Black,
                        start = Offset(graphContentLeft, zeroLineYScreen),
                        end = Offset(graphContentRight, zeroLineYScreen),
                        strokeWidth = 3.0f
                    )
                }
            }

            // --- X軸の目盛りとラベル描画 (X軸ズーム対応 - 現状X軸は固定) ---
            if (graphContentWidth > 0f && currentViewportWidthMs > 0f) {
                val numXTicksTarget = 5
                var xTickIntervalMs = currentViewportWidthMs / numXTicksTarget
                val niceIntervals = listOf(1f, 2f, 5f, 10f, 20f, 25f, 50f, 100f)
                xTickIntervalMs = niceIntervals.minByOrNull { abs(it - xTickIntervalMs) } ?: xTickIntervalMs
                if (xTickIntervalMs < 1f && currentViewportWidthMs < 10f) xTickIntervalMs = currentViewportWidthMs / 2f
                if (xTickIntervalMs == 0f) xTickIntervalMs = 1f

                val firstTickCandidate = ceil(visibleStartMs / xTickIntervalMs) * xTickIntervalMs
                var currentTickMs = if (firstTickCandidate < visibleStartMs && abs(firstTickCandidate - visibleStartMs) > 1e-6f) firstTickCandidate + xTickIntervalMs else firstTickCandidate

                val xTickLabelYPosition = graphContentBottom + bottomPadding / 2.0f + tickLabelPaint.descent()

                while (currentTickMs <= visibleEndMs + 1e-3) {
                    val tickScreenX = graphContentLeft + ((currentTickMs - visibleStartMs) / currentViewportWidthMs) * graphContentWidth
                    if (tickScreenX >= graphContentLeft && tickScreenX <= graphContentRight + 1f) {
                        drawLine( color = Color.Black, start = Offset(tickScreenX, graphContentBottom), end = Offset(tickScreenX, graphContentBottom + 5.dp.toPx()), strokeWidth = 3.0f )
                        drawContext.canvas.nativeCanvas.drawText( "${currentTickMs.toInt()}", tickScreenX, xTickLabelYPosition, tickLabelPaint )
                    }
                    if (xTickIntervalMs <= 1e-6f) break
                    currentTickMs += xTickIntervalMs
                }
            }

            // --- グラフデータ描画 (X軸・Y軸ズーム対応) ---
            if (result.isNotEmpty() && graphContentWidth > 0f && graphContentHeight > 0f && currentViewportWidthMs > 0f && currentViewportYSpan > 0f) {
                val path = Path()
                var firstPointInView = true

                for (i in result.indices) {
                    val timeMs = (i.toFloat() / sampleRate.toFloat()) * 1000f
                    val correlationValue = result[i]

                    val isXInView = timeMs >= visibleStartMs - 1e-3f && timeMs <= visibleEndMs + 1e-3f

                    if (isXInView) {
                        val screenX = graphContentLeft + ((timeMs - visibleStartMs) / currentViewportWidthMs) * graphContentWidth
                        val screenY = (graphContentTop + ((visibleYMax - correlationValue) / currentViewportYSpan) * graphContentHeight)
                            .coerceIn(graphContentTop, graphContentBottom)

                        if (firstPointInView) {
                            path.moveTo(screenX.coerceIn(graphContentLeft, graphContentRight), screenY)
                            firstPointInView = false
                        } else {
                            path.lineTo(screenX.coerceIn(graphContentLeft, graphContentRight), screenY)
                        }
                    } else if (timeMs > visibleEndMs && !firstPointInView) {
                        val screenX = graphContentLeft + ((timeMs - visibleStartMs) / currentViewportWidthMs) * graphContentWidth
                        val screenY = (graphContentTop + ((visibleYMax - correlationValue) / currentViewportYSpan) * graphContentHeight)
                            .coerceIn(graphContentTop, graphContentBottom)
                        path.lineTo(screenX.coerceIn(graphContentLeft, graphContentRight), screenY)
                        break
                    }
                }
                if (!firstPointInView) {
                    drawPath(path = path, color = primaryColor, style = Stroke(width = 3.5f))
                }

                // --- ピーク描画 (X軸・Y軸ズーム対応) ---
                peakInfo?.let { (index, value) ->
                    val peakTimeMs = (index.toFloat() / sampleRate.toFloat()) * 1000f
                    val peakCorrelationValue = value

                    if (peakTimeMs >= visibleStartMs && peakTimeMs <= visibleEndMs &&
                        peakCorrelationValue >= visibleYMin && peakCorrelationValue <= visibleYMax) {

                        val peakScreenX = graphContentLeft + ((peakTimeMs - visibleStartMs) / currentViewportWidthMs) * graphContentWidth
                        val peakScreenY = graphContentTop + ((visibleYMax - peakCorrelationValue) / currentViewportYSpan) * graphContentHeight

                        if (peakScreenX >= graphContentLeft && peakScreenX <= graphContentRight &&
                            peakScreenY >= graphContentTop && peakScreenY <= graphContentBottom) {
                            drawCircle(color = orangeColor, radius = 8f, center = Offset(peakScreenX, peakScreenY))
                            val peakValueText = String.format("%.3f", peakCorrelationValue)
                            drawContext.canvas.nativeCanvas.drawText(peakValueText, peakScreenX + 10.dp.toPx(), peakScreenY - 5.dp.toPx(), peakValuePaint)
                        }
                    }
                }
            }
        }
    }

    // --- 権限関連 (変更なし) ---
    private fun checkAndRequestPermission() { /* ... as before ... */
        when {
            ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED -> {
                if (!hasPermission) { Log.d(TAG, "Permission already granted."); hasPermission = true; initAudioRecord() }
                else if (!isInitialized && audioRecord == null) { initAudioRecord() }
            }
            shouldShowRequestPermissionRationale(Manifest.permission.RECORD_AUDIO) -> {
                Log.i(TAG, "Showing permission rationale."); hasPermission = false; statusText = "マイク権限が必要です"
                Toast.makeText(this, "録音にはマイク権限の許可が必要です", Toast.LENGTH_LONG).show(); requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
            }
            else -> { Log.d(TAG, "Requesting permission."); hasPermission = false; requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO) }
        }
    }
    // --- AudioRecord初期化 (変更なし) ---
    @RequiresPermission(Manifest.permission.RECORD_AUDIO)
    private fun initAudioRecord() { /* ... as before ... */
        if (audioRecord != null || !hasPermission) return
        minBufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat)
        if (minBufferSize <= 0) { Log.e(TAG, "Invalid AudioRecord parameters."); statusText = "AudioRecordパラメータエラー"; isInitialized = false; audioRecord = null; return }
        bufferSizeInBytes = minBufferSize * 2
        Log.d(TAG, "minBufferSize: $minBufferSize, used bufferSize: $bufferSizeInBytes")
        try {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) { Log.e(TAG, "FATAL: Permission check failed inside initAudioRecord!"); hasPermission = false; statusText = "マイク権限エラー（内部確認）"; isInitialized = false; return }
            audioRecord = AudioRecord(MediaRecorder.AudioSource.MIC, sampleRate, channelConfig, audioFormat, bufferSizeInBytes)
            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) { Log.e(TAG, "AudioRecord failed to initialize."); statusText = "AudioRecord初期化失敗"; isInitialized = false; audioRecord?.release(); audioRecord = null }
            else { Log.d(TAG, "AudioRecord initialized successfully."); statusText = if (!isRecording) "待機中" else statusText; isInitialized = true }
        } catch (e: SecurityException) { Log.e(TAG, "SecurityException initializing AudioRecord", e); statusText = "初期化エラー: 権限がありません"; isInitialized = false; hasPermission = false; audioRecord = null }
        catch (e: Exception) { Log.e(TAG, "Exception initializing AudioRecord", e); statusText = "初期化エラー: ${e.message}"; isInitialized = false; audioRecord = null }
    }

    // --- 録音開始と定期計算開始 (Y軸ズームリセット呼び出し変更なし) ---
    private fun startRecordingAndPeriodicCalculation(scope: CoroutineScope) {
        if (!hasPermission) { Log.w(TAG, "Start recording denied. Missing permission."); statusText = "マイク権限がありません"; checkAndRequestPermission(); return }
        if (!isInitialized || audioRecord == null) { Log.w(TAG, "Start recording denied. AudioRecord not initialized."); statusText = "AudioRecord未初期化"; initAudioRecord(); return }
        if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) { Log.e(TAG, "Start recording failed. AudioRecord not in initialized state."); statusText = "AudioRecord状態異常"; audioRecord?.release(); audioRecord = null; isInitialized = false; checkAndRequestPermission(); return }
        if (isRecording) { Log.w(TAG, "Already recording."); return }

        recordedAudioBuffer.clear()
        correlationResult = emptyList()
        currentDbLevel = MIN_DB_LEVEL
        levelFeedbackText = ""
        resetGraphYZoom() // Y軸ズームのみリセット

        try {
            audioRecord?.startRecording()
            isRecording = true
            statusText = "録音中..."
            Log.d(TAG, "Recording started.")
            recordingThread = thread(start = true) { processAudioStream() }
            calculationCoroutineJob?.cancel()
            calculationCoroutineJob = scope.launch(Dispatchers.IO) {
                Log.d(TAG, "Periodic calculation coroutine started.")
                while (isActive && isRecording) {
                    delay(calculationIntervalMs)
                    if (!isActive || !isRecording) break
                    launch(Dispatchers.Default) { performCorrelationCalculation() }
                }
                Log.d(TAG, "Periodic calculation coroutine finished.")
            }
        } catch (e: IllegalStateException) { Log.e(TAG, "Failed to start recording", e); statusText = "録音開始エラー"; isRecording = false }
    }
    // --- 音声データ処理 (変更なし) ---
    private fun processAudioStream() { /* ... as before ... */
        Log.d(TAG, "Audio processing thread started.")
        val audioDataShort = ShortArray(bufferSizeInBytes / 2)
        Log.d(TAG, "Entering processAudioStream loop. isRecording=$isRecording")
        while (isRecording) {
            val shortsRead = audioRecord?.read(audioDataShort, 0, audioDataShort.size) ?: -1
            if (shortsRead < 0) { Log.e(TAG, "Read() error: $shortsRead"); break }
            else if (shortsRead > 0) {
                val copy = audioDataShort.copyOfRange(0, shortsRead)
                synchronized(recordedAudioBuffer) {
                    recordedAudioBuffer.addAll(copy.toList())
                    val maxBufferSamples = sampleRate * (calculationDataDurationSec + 2)
                    if (recordedAudioBuffer.size > maxBufferSamples) {
                        val removeCount = recordedAudioBuffer.size - maxBufferSamples
                        for(i in 0 until removeCount) recordedAudioBuffer.removeAt(0)
                    }
                }
                var sumOfSquares = 0.0
                for (i in 0 until shortsRead) {
                    val normalizedSample = copy[i].toDouble() / Short.MAX_VALUE.toDouble()
                    sumOfSquares += normalizedSample.pow(2)
                }
                val meanSquare = if (shortsRead > 0) sumOfSquares / shortsRead else 0.0
                val rms = sqrt(meanSquare)
                val dbfs = if (rms > 1e-10) { (20.0 * log10(rms)).toFloat() } else { MIN_DB_LEVEL }
                val feedback = when {
                    dbfs < LEVEL_THRESHOLD_LOW -> "音が小さい可能性があります"
                    dbfs >= LEVEL_THRESHOLD_IDEAL_LOW && dbfs < LEVEL_THRESHOLD_IDEAL_HIGH -> "理想的な音量レベル"
                    dbfs >= LEVEL_THRESHOLD_HIGH -> "音が大きい可能性があります"
                    else -> ""
                }
                runOnUiThread { currentDbLevel = dbfs; levelFeedbackText = feedback }
            }
        }
        Log.d(TAG, "Exiting processAudioStream loop.")
        Log.d(TAG, "Audio processing thread finished.")
    }

    // ★★★ 定期的に呼ばれる相関計算処理 (変更なし) ★★★
    private suspend fun performCorrelationCalculation() { /* ... as before ... */
        Log.d(TAG, "Performing correlation calculation...")
        val samplesToTake = sampleRate * calculationDataDurationSec
        val recordedData: ShortArray
        synchronized(recordedAudioBuffer) {
            val startIndex = (recordedAudioBuffer.size - samplesToTake).coerceAtLeast(0)
            if (recordedAudioBuffer.size - startIndex < M_SEQUENCE_FLOAT_ARRAY.size) {
                Log.d(TAG, "Buffer too short for correlation (${recordedAudioBuffer.size - startIndex}), skipping calculation.")
                return
            }
            recordedData = recordedAudioBuffer.subList(startIndex, recordedAudioBuffer.size).toShortArray()
        }
        Log.d(TAG, "Using last ${recordedData.size} samples for calculation.")
        val referenceSignal = M_SEQUENCE_FLOAT_ARRAY
        val rawCorrelation = calculateCrossCorrelationTimeDomainFull(recordedData, referenceSignal)
        Log.d(TAG, "Raw correlation calculated. Size: ${rawCorrelation.size}")
        val normalizedCorrelation = normalizeCrossCorrelation(rawCorrelation, recordedData, referenceSignal)
        Log.d(TAG, "Correlation normalized by new method.")
        val samplesForDisplay = (sampleRate.toFloat() * (INITIAL_GRAPH_VIEWPORT_WIDTH_MS / 1000f)).toInt()
        val resultSize = min(normalizedCorrelation.size, samplesForDisplay.coerceAtLeast(M_SEQUENCE_FLOAT_ARRAY.size))
        val correlationForGraph = if (resultSize > 0) { normalizedCorrelation.copyOfRange(0, resultSize).toList() } else { emptyList() }
        withContext(Dispatchers.Main) { correlationResult = correlationForGraph; Log.d(TAG, "Correlation graph data updated (${correlationForGraph.size} points).") }
    }

    // --- 録音停止と定期計算停止 (変更なし) ---
    private fun stopRecordingAndCalculation() { /* ... as before ... */
        if (!isRecording) return
        stopRecordingInternal(calculate = false)
        runOnUiThread { currentDbLevel = MIN_DB_LEVEL; levelFeedbackText = "" }
    }
    // --- 内部的な停止処理 (変更なし) ---
    private fun stopRecordingInternal(calculate: Boolean = false, scope: CoroutineScope? = null) { /* ... as before ... */
        if (!isRecording && audioRecord?.recordingState != AudioRecord.RECORDSTATE_RECORDING) { return }
        Log.d(TAG, "Stopping recording internal... Calculate = $calculate")
        isRecording = false
        calculationCoroutineJob?.cancel()
        calculationCoroutineJob = null
        Log.d(TAG, "Periodic calculation coroutine cancelled.")
        try { recordingThread?.join(500) }
        catch (e: InterruptedException) { Thread.currentThread().interrupt(); Log.e(TAG, "Interrupted while waiting for recording thread", e) }
        recordingThread = null
        if (audioRecord?.recordingState == AudioRecord.RECORDSTATE_RECORDING) { try { audioRecord?.stop(); Log.d(TAG, "AudioRecord stopped successfully.") } catch (e: IllegalStateException) { Log.e(TAG, "Failed to stop AudioRecord", e) } }
        else { Log.w(TAG, "AudioRecord was not recording when stop was requested.") }
        Log.d(TAG, "Stopped recording. Total samples in buffer: ${recordedAudioBuffer.size}")
        runOnUiThread {
            if (statusText.contains("エラー")) { /* No change */ }
            else if (isInitialized) { statusText = "停止" }
        }
        Log.d(TAG, "Recording fully stopped internal.")
    }
    // --- 時間領域相互相関関数 (変更なし) ---
    private fun calculateCrossCorrelationTimeDomainFull(longSignal: ShortArray, shortSignal: FloatArray): FloatArray { /* ... as before ... */
        if (shortSignal.isEmpty() || longSignal.size < shortSignal.size) { Log.e(TAG, "calculateCrossCorrelationTimeDomainFull: 入力信号の長さが不正です。longSignal.size=${longSignal.size}, shortSignal.size=${shortSignal.size}"); return FloatArray(0) }
        val n = longSignal.size; val m = shortSignal.size; val resultLength = n - m + 1; val correlationResultOutput = FloatArray(resultLength)
        for (j in 0 until resultLength) { var sumOfProducts = 0.0f; for (k in 0 until m) { sumOfProducts += longSignal[j + k].toFloat() * shortSignal[k] }; correlationResultOutput[j] = sumOfProducts }
        return correlationResultOutput
    }

    // --- 正規化関数 (normalizeByCorrelationPower - 変更なし) ---
    private fun normalizeByCorrelationPower(correlationDataInput: FloatArray, longSignal: ShortArray, shortSignalLength: Int ): FloatArray { /* ... as before ... */
        Log.d(TAG, "normalizeByCorrelationPower: 開始 data.size=${correlationDataInput.size}")
        if (correlationDataInput.isEmpty() || shortSignalLength <= 0 || longSignal.size < shortSignalLength) {
            Log.w(TAG, "normalizeByCorrelationPower: 入力データが不正です。")
            return FloatArray(0)
        }
        val m = shortSignalLength
        val resultLength = correlationDataInput.size
        val normalizedResult = FloatArray(resultLength)
        for (j in 0 until resultLength) {
            var sumAbsLongSignalWindow = 0.0
            for (k in 0 until m) {
                sumAbsLongSignalWindow += abs(longSignal[j + k].toDouble())
            }
            val normFactor = sqrt(sumAbsLongSignalWindow)
            if (abs(normFactor) < 1e-9) {
                normalizedResult[j] = 0.0f
            } else {
                normalizedResult[j] = (correlationDataInput[j].toDouble() / normFactor).toFloat()
            }
        }
        Log.d(TAG, "normalizeByCorrelationPower: 完了")
        return normalizedResult
    }

    // ★★★ sp を px に変換する拡張関数 (変更なし) ★★★
    fun Float.spToPx(density: Float, fontScale: Float): Float = this * fontScale * density
    fun Int.spToPx(density: Float, fontScale: Float): Float = this.toFloat().spToPx(density, fontScale)
    fun androidx.compose.ui.unit.TextUnit.toPx(density: Float, fontScale: Float): Float {
        return if (this.isSp) this.value.spToPx(density, fontScale) else this.value
    }

    // ★★★ 新しい正規化関数 (標準的な正規化相互相関 - 変更なし) ★★★
    private fun normalizeCrossCorrelation( rawCorrelation: FloatArray, longSignal: ShortArray, shortSignal: FloatArray ): FloatArray { /* ... as before ... */
        Log.d(TAG, "normalizeCrossCorrelation: 開始 rawCorrelation.size=${rawCorrelation.size}, longSignal.size=${longSignal.size}, shortSignal.size=${shortSignal.size}")
        if (rawCorrelation.isEmpty() || shortSignal.isEmpty() || longSignal.size < shortSignal.size) {
            Log.w(TAG, "normalizeCrossCorrelation: 入力データが不正です。rawCorrelation empty: ${rawCorrelation.isEmpty()}, shortSignal empty: ${shortSignal.isEmpty()}, longSignal too short: ${longSignal.size < shortSignal.size}")
            return FloatArray(0)
        }
        val m = shortSignal.size
        val resultLength = rawCorrelation.size
        if (resultLength <= 0) {
            Log.w(TAG, "normalizeCrossCorrelation: resultLength is non-positive: $resultLength")
            return FloatArray(0)
        }
        val normalizedResult = FloatArray(resultLength)
        var sumSqShortSignal = 0.0
        for (sampleValue in shortSignal) {
            sumSqShortSignal += sampleValue.toDouble() * sampleValue.toDouble()
        }
        val energyShortSignalSqrt = sqrt(sumSqShortSignal)
        if (abs(energyShortSignalSqrt) < 1e-9) {
            Log.w(TAG, "normalizeCrossCorrelation: 参照信号のエネルギーがほぼゼロです (sqrt: $energyShortSignalSqrt).")
            return FloatArray(resultLength) { 0.0f }
        }
        for (j in 0 until resultLength) {
            var sumSqLongSignalWindow = 0.0
            for (k in 0 until m) {
                if (j + k >= longSignal.size) {
                    Log.e(TAG, "normalizeCrossCorrelation: Index out of bounds for longSignal. j=$j, k=$k, m=$m, longSignal.size=${longSignal.size}")
                    normalizedResult[j] = 0.0f
                    continue
                }
                val sample = longSignal[j + k].toDouble()
                sumSqLongSignalWindow += sample * sample
            }
            val energyLongSignalWindowSqrt = sqrt(sumSqLongSignalWindow)
            val normFactor = energyShortSignalSqrt * energyLongSignalWindowSqrt
            if (abs(normFactor) < 1e-9) {
                normalizedResult[j] = 0.0f
            } else {
                normalizedResult[j] = (rawCorrelation[j].toDouble() / normFactor).toFloat()
            }
        }
        Log.d(TAG, "normalizeCrossCorrelation: 完了. First few normalized values: ${normalizedResult.take(5).joinToString { String.format("%.3f", it) }}")
        return normalizedResult
    }
} // End of MainActivity
